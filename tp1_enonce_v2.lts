//************************************************************************//
//************************************************************************//
// Noms des membres de l'équipe ******************************************//
// 1.  	Elie Audette 
// 2.  	Ernest Niederman 
// 3. 	Norma-Yan Mercier 
// 4. 
//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 1 (Total : 2.5 points)
// Analyser le processus suivant.
PUB1 = (compute -> connect -> pub -> PUB1).
SUB1 = (connect -> sub -> compute -> SUB1).
BROKER1 = (connect -> PUBSUB),
  PUBSUB = (pub -> queue -> BROKER1
	       | sub -> dequeue -> BROKER1).
||SYSTEM1 = (PUB1 || SUB1 || BROKER1).

//************************************************************************//
// Question 1.1 (2.5 points)
// Faites dessinez la composition parallèle via le menu Draw.
// Expliquer pourquoi la composition parallèle donne un seul état.
// Réponse : À cause des actions partagées. Interblocage.
// Si on regarde les premières actions de SUB1 et BROKER1, c'est connect.
// Action connect est partégée par PUB1, SUB1 et BROKER1. Pour être synchronisé
// et faire connect, PUB1 doit aussi faire compute qui est bloqué par l'attente 
// de SUB1 de faire connect.
//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 2 (Total : 2.5 points)
// Analyser le processus suivant.
PUB2 = (supply -> connect -> pub -> PUB2).
SUB2 = (connect -> sub -> consume -> SUB2).
BROKER2 = (connect -> PUBSUB),
  PUBSUB = (pub -> queue -> BROKER2
	       | sub -> dequeue -> BROKER2).
||SYSTEM2 = (PUB2 || SUB2 || BROKER2).

//************************************************************************//
// Question 2.1 (2.5 points)
// En vous appuyant sur les actions partagées lors de la composition
// parallèle, dites si les actions connect au processus BROKER2 se font de 
// façon synchrone ou asynchrone entre le pub et le sub.
// Réponse : De façon synchrone.
// L'action connect est partagée avec PUB2, SUB2 et BROKER2. Tous doivent
// être rendus pour faire l'action connect. Ensuite, l'action pub de BROKER2 est 
// partagée avec PUB2 et l'action sub de BROKER2 est partagée avec SUB2.
//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 3 (Total : 5 points)
// 3. Analyser le processus suivant.
PUB3 = (supply -> connect_pub -> pub -> PUB3).
SUB3 = (connect_sub -> sub -> consume -> SUB3).
BROKER3 = ({connect_sub, connect_pub} -> PUBSUB),
  PUBSUB = (pub -> queue -> BROKER3
	       | sub -> dequeue -> BROKER3).
||SYSTEM3 = (PUB3 || SUB3 || BROKER3).

//************************************************************************//
// Question 3.1 (2.5 points)
// Donnez une spécification FSP différente, mais produisant le même LTSA.
// Réponse : Le "choix"
PUB0 = (supply -> connect_pub -> pub -> PUB0).
SUB0 = (connect_sub -> sub -> consume -> SUB0).
BROKER0 = (connect_sub -> PUBSUB | connect_pub-> PUBSUB),
  PUBSUB = (pub -> queue -> BROKER0
	       | sub -> dequeue -> BROKER0).
||SYSTEM0 = (PUB0 || SUB0 || BROKER0).

//************************************************************************//
// Question 3.2 (2.5 points)
// Deux spécifications FSP syntaxiquement différentes peuvent donner le même LTSA.
// Est-il possible que deux spécifications FSP syntaxiquement différentes peuvent 
// donner le même LTSA? Si oui, justifiez. Sinon, justifiez.
// Réponse : Oui
// Justification : Un des exemples pour lequel LTSA peut donner le même résultat
// c'est le "choix" qui est synthaxiquement différente, mais donne le même LTSA : 
// {connect_sub, connect_pub} -> PUBSUB
// équivalent à (connect_sub -> PUBSUB | connect_pub-> PUBSUB)
//
// On a aussi vu dans le cours que LTSA ne montre pas les états non atteignables,
// que des noms de processus différents peuvent produire le même LTSA, etc.
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 4 (Total : 10 points)
// Dans le processus SYSTEM3, il est possible de consommer un message avant 
// qu'il ne soit produit.


//************************************************************************//
// Question 4.1 (1 point)
// Définissez une constante N égale à 2 représentant la taille du buffer 
// du broker
// Réponse :
const N = 2

//************************************************************************//
// Question 4.2 (8 points)
// En conservant les mêmes actions que le processus BROKER3,
// définissez le processus BROKER4 qui empêche la consommation avant la production
// et qui permet d'avoir au plus N messages stockés par le broker.
// Donc les publishers ne peuvent plus publier quand N messages sont présents
// sur le BROKER.
// Réponse :

BROKER4 = BROKER_AUX[0],
  BROKER_AUX[0] = (connect_pub -> PUBSUB[0]),
  BROKER_AUX[N] = (connect_sub -> PUBSUB[N]),
  BROKER_AUX[i:1..N-1] = ({connect_pub, connect_sub} -> PUBSUB[i]),
	PUBSUB[i:0..N] = (when (i < N) pub -> queue -> BROKER_AUX[i+1]
					 | when (i > 0) sub -> dequeue -> BROKER_AUX[i-1]).

//************************************************************************//
// Question 4.3 (1 point)
// Définissez le processus SYSTEM4 qui met en parallèle PUB3, SUB3 et BROKER4.
// Vérifiez le blocage et le progrès.
// Réponse :
||SYSTEM4 = (PUB3 || SUB3 || BROKER4).
// Pas de blocage, ni de violation de progrès.

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 5 (Total : 10 points)

//************************************************************************//
// Question 5.1 (1 point)
// Définissez ces deux constantes :
// 1. NB_P = 2 : représentant le nombre de publishers
// 2. NB_S = 3 : représentant le nombre de subscribers
// Réponse :

const NB_P = 2
const NB_S = 3

//************************************************************************//
// Question 5.2 (1 point)
// Défnissez deux ranges R_NB_P et R_NB_S.
// 1. R_NB_P = 1 à P : représentant l'identifiant de chacun des publishers
// 2. R_NB_S = 1 à S : représentant l'identifiant de chacun des subscribers.
// Réponse :

range R_NB_P = 1..NB_P
range R_NB_S = 1..NB_S

//************************************************************************//
// Question 5.3 (1 points)
// Défnissez deux ensembles P et S
// 1. P contenant uniquement le préfixe "publisher"
//      et représentant un préfixe pour les actions des publishers
// 2. S contenant uniquement le préfixe "subscriber"
//      et représentant un préfixe pour les actions des subscribers
// Réponse :

set P = { publisher }
set S = { subscriber }

//************************************************************************//
// Question 5.4 (3 points)
// Défnissez ces trois ensembles.
// 1. PREFIXES_PUB : cet ensemble représente l'ensemble des préfixes des
//                   publishers. Il contient un seul élément qui est la
//                   concaténation de l'ensemble P avec la range R_NB_P.
// 2. PREFIXES_SUB : cet ensemble représente l'ensemble des préfixes des
//                   subscribers. Il contient un seul élément qui est la
//                   concaténation de l'ensemble S avec la range R_NB_S.
// 3. PREFIXES : cet ensemble représente l'ensemble des préfixes possibles.
//               Il contient deux éléments PREFIXES_PUB et PREFIXES_SUB.
// Réponse :

set PREFIXES_PUB = {publisher[R_NB_P]}
set PREFIXES_SUB = {subscriber[R_NB_S]}
set PREFIXES = {PREFIXES_PUB, PREFIXES_SUB}

//************************************************************************//
// Question 5.5 (4 points)
// Définissez le processus SYSTEM5 qui met en parallèle PREFIXES_PUB PUB3,
// PREFIXES_SUB SUB3 et qui se partage PREFIXES BROKER4.
// Vérifiez le blocage et le progrès.
// Réponse : 
// SYSTEM5 = publisher.1:PUB3 || publisher.2:PUB3 || subscriber.1:SUB3 || subscriber.2:SUB3 || subscriber.3:SUB3 || {publisher.1,publisher.2,subscriber.1,subscriber.2,subscriber.3}::BROKER4
||SYSTEM5 = (
    {PREFIXES_PUB}:PUB3 || 
    {PREFIXES_SUB}:SUB3 || 
    {PREFIXES}::BROKER4      // Le broker unique accepte les actions des deux ensembles
).
// Pas de blocage, ni de violation de progrès.

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 6 (Total : 10 points)

//************************************************************************//
// Question 6.1 (2 points)
// Utiliser le menu Check -> Run -> Default. Que remarquez-vous avec les 
// actions queue et dequeue préfixées? Comment faire pour que ces actions
// internes au BROKER4 (queue et dequeue) soient centralisées? Autrement
// dit, par exemple, 1.queue et 2.queue devraient désigner la même action?
// Réponse : Il faut les renommer.

//************************************************************************//
// Question 6.2 (8 points)
// Définissez un processus SYSTEM6 à partir du processus SYSTEM5 dans lequel
// vous utilisez l'opérateur de renommage afin de renommer les actions 
// préfixées queue et dequeue de telle façon à ce qu'elles soient centralisées.
// Vérifiez le blocage et le progrès.
// Réponse :
//||SYSTEM6 = SYSTEM5 / {queue / {PREFIXES}.queue, dequeue / {PREFIXES}.dequeue}.
||SYSTEM6 = (
    {PREFIXES_PUB}:PUB3 || 
    {PREFIXES_SUB}:SUB3 || 
    {PREFIXES}::BROKER4      
	) / {queue / {PREFIXES}.queue, dequeue / {PREFIXES}.dequeue}.

// Pas de blocage, ni de violation de progrès.
// En effectuant ce renommage, toutes les actions du type: publisher[1].queue, publisher[2].queue, subscriber[1].queue, etc.
// sont synchronisées sur l'action unique 'queue'. Il en va de même pour 'dequeue'. Valider avec animator.

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 7 (Total : 20 points)

//************************************************************************//
// Question 7.1 (2 points)
// En utilisant le menu Check -> Run -> Default, 
// que remarquez-vous au niveau des actions?
// Lesquels ne sont pas synchronisés et pourquoi?
// Réponse : Les actions de communication pub, sub, connect_pub et connect_sub.
// En effet, puisqu'ils se partagent le broker, les publishers peuvent faire sub et
// connect_sub et les subscribers peuvent faire pub et connect_pub

//************************************************************************//
// Question 7.2 (2 points)
// Définissez deux ensembles.
// 1. PUB_LABELS : l'ensemble des actions partagées entre les publishers
//                 et le broker, c.-à-d., connect_pub et pub.
// 1. SUB_LABELS : l'ensemble des actions partagées entre les subscribers
//                 et le broker, c.-à-d., connect_sub et sub.
// Réponse :

set PUB_LABELS = {connect_pub, pub}
set SUB_LABELS = {connect_sub, sub}

//************************************************************************//

// Question 7.3 (9 points)
// En utilisant uniquement le processus STOP, PREFIXES_SUB, PREFIXES_PUB,
// PUB_LABELS, SUB_LABELS et l'opérateur d'extension de l'alphabet +,
// définissez un processus FORBIDDEN qui mis en parallèle avec le broker 
// empêchera les actions identifiées en 7.1 d'être exécutées.
// Réponse :

// On veut interdire ces actions préfixées non-synchronisées (7.1). 
// La stratégie : mettre en parallèle un processus qui refuse toujours d'exécuter ces actions.
// STOP est un processus qui ne fait jamais rien — il bloque tout ce qui est dans son alphabet.
// Mise en parallèle avec BROKER forcera ces actions à être partagées et donc bloquées.

FORBIDDEN = STOP + {PREFIXES_PUB.SUB_LABELS, PREFIXES_SUB.PUB_LABELS}.

//************************************************************************//
// Question 7.4 (2 points)
// Définissez un processus SYSTEM7 qui met en parallèle PREFIXES_PUB PUB3,
// PREFIXES_SUB SUB3, FORBIDDEN et se partage PREFIXES BROKER4.
// N'oubliez pas les renommages de queue et dequeue.
// Réponse :
||SYSTEM7 = (
    {PREFIXES_PUB}:PUB3 ||
    {PREFIXES_SUB}:SUB3 ||
    FORBIDDEN ||
    {PREFIXES}::BROKER4)
	 / {queue / {PREFIXES}.queue, dequeue / {PREFIXES}.dequeue}.

//************************************************************************//
// Question 7.5 (5 points)
// Valider le blocage et le progrès. L'un des deux n'est pas respecté.
// Expliquez pourquoi? Que pouvez-vous en conclure sur votre processus
// FORBIDDEN?
// Réponse :
// Pas de blocage, mais il y a violation du progrès pour les actions suivantes:
// {publisher[1..2].{connect_sub, sub}, subscriber[1..3].{connect_pub, pub}}
// En gros, à cause de FORBIDDEN, il ne peut jamais effectuer ces actions 
// ci-dessus, mais en fait c'est une bonne chose, c'est notre but et valider par
// ensemble terminal d'actions légitimes.
// Actions in terminal set:
// {dequeue, publisher[1..2].{connect_pub, pub, supply}, queue, subscriber[1..3].{connect_sub, consume, sub}}

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 8 (Total : 10 points)

//************************************************************************//
// Question 8.1 (5 points)
// Afin de valider le processus FORBIDDEN, écrivez une propriété 
// FORBIDDEN_VALIDATOR qui valide que FORBIDDEN fonctionne.
// Autrement dit, toutes les actions identifiées en 7.1 mènent à l'état
// d'erreur, tandis que toutes les autres actions sont permis.
// Réponse :
set ALL_FORBIDDEN = {PREFIXES_PUB.SUB_LABELS, PREFIXES_SUB.PUB_LABELS}
property FORBIDDEN_VALIDATOR = STOP + ALL_FORBIDDEN.

//************************************************************************//
// Question 8.2 (2 points)
// Définissez un processus SYSTEM8 qui met en parallèle SYSTEM7 et
// FORBIDDEN_VALIDATOR.
// Lors de la compilation, FORBIDDEN_VALIDATOR doit être respectée.
// N'oubliez pas les renommages de queue et dequeue.
// Réponse :
||SYSTEM8 = (
    {PREFIXES_PUB}:PUB3 ||
    {PREFIXES_SUB}:SUB3 ||
    FORBIDDEN ||
    {PREFIXES}::BROKER4 ||
	FORBIDDEN_VALIDATOR
	) / {queue / {PREFIXES}.queue, dequeue / {PREFIXES}.dequeue}.

//Compilation
//Compiled: PUB3
//Compiled: SUB3
//Compiled: FORBIDDEN
//Compiled: BROKER4
//Compiled: FORBIDDEN_VALIDATOR

//************************************************************************ //
// Question 8.3 (2 points)
// Comparer SYSTEM7 et SYSTEM8 en terme de nombre d'états, de nombre de
// transitions, de blocage et de progrès.
// Expliquez vos résultats.
// Réponse : 
// SYSTEM7 et SYSTEM8 ont le même nombre d'états (State Space) et le même nombre 
// de transitions (Transitions).
// Pas de blocage pour SYSTEM7 et SYSTEM8.
// Toujours la violation de progrès pour SYSTEM7 et SYSTEM8 (même actions et ensemble
// terminal). C'est normal car FORBIDDEN_VALIDATOR est une property et donc
// par sa transparence ne devrait pas affecter le comportement de notre système.

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 9 (Total : 10 points)

//************************************************************************//
// Question 9.1 (7 points)
// À partir de la question 7, nous avons des transitions "indésirables".
// Définissez un processus SYSTEM9 égale à SYSTEM8 avec un masquage des 
// actions indésirables déterminées à la question 7.1.
// Réponse :

||SYSTEM9 = (
    {PREFIXES_PUB}:PUB3 ||
    {PREFIXES_SUB}:SUB3 ||
    FORBIDDEN ||
    {PREFIXES}::BROKER4 ||
	FORBIDDEN_VALIDATOR
	) / {queue / {PREFIXES}.queue, dequeue / {PREFIXES}.dequeue} 
	\ {PREFIXES_PUB.SUB_LABELS, PREFIXES_SUB.PUB_LABELS}.

//************************************************************************//
// Question 9.2 (3 points)
// Comparer SYSTEM8 et SYSTEM9 en terme de blocage et de progrès.
// Expliquez vos résultats.
// Réponse : En ayant masqué, les actions indésirables, il n'y a plus de 
// violation du progrès dans SYSTEM9 alors qu'il y en avait dans
// SYSTEM7 et SYSTEM8. Le blocage reste pareil (il n'y a pas de blocage).

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 10 (Total : 10 points)

//************************************************************************//
// Question 10.1 (1 point)
// Définissez un ensemble APPS contenant les étiquettes i et t représentant 
// respectivement une application d'indemnisation et de tarification.
// Réponse :

set APPS = {i, t}


//************************************************************************//
// Question 10.2 (9 points)
// Définissez un processus SYSTEM10 qui met en parallèle les mêmes processus
// que SYSTEM8, MAIS qui les préfixe tous par l'ensemble APPS.
// Il faut conserver et ajuster les renommages de queue et dequeue,
// et les masquages ajoutés à la question 9.1.
// 
// Vérfiez l'absence de blocage et le progrès.
// Réponse : Pas de blocage, ni de violation du progrès

||SYSTEM10 = (
    {APPS, PREFIXES_PUB}:PUB3 ||
    {APPS, PREFIXES_SUB}:SUB3 ||
    {APPS}:FORBIDDEN ||
    {APPS, PREFIXES}::BROKER4 ||
    {APPS}:FORBIDDEN_VALIDATOR
	) / {queue / {APPS, PREFIXES}.queue, dequeue / {APPS, PREFIXES}.dequeue}
  	\ {APPS.PREFIXES_PUB.SUB_LABELS, APPS.PREFIXES_SUB.PUB_LABELS}.

//************************************************************************//
//************************************************************************//


//************************************************************************//
//************************************************************************//
// Question 11 (Total : 10 points)

//************************************************************************//
// Question 11.1 (2 points)
// En utilisant le menu Check -> Run -> Default, que remarquez-vous au 
// niveau des actions? Est-il possible pour un subscriber i de consommer
// un message de t? Et vice versa? Pourquoi?
// Réponse : Par exemple, on voit des actions comme i.publish, t.publish, 
// i.subscribe, t.subscribe. Un message publié de i ne pourra jamais
// être consommé par un subscriber de t, et inversement. 
// Isolation car aucune action commune.

//************************************************************************//
// Question 11.2 (8 points)
// Définissez un controlleur CONTROLLER_SUB_SAME_ORIGIN_PUB qui via les 
// actions connect_pub et connect_sub s'assurera d'une consommation adéquate.
// Réponse : Dans le forum, le prof donne indice c'est uniquement un compteur.
// Donc si j'ai cinq i et quatre t, cinq i et quatre t peuvent être consommés.

COUNTER(N=0) = COUNT[0], 
COUNT[n:0..N] = (when (n < N) connect_pub -> COUNT[n+1]
     			| when (n > 0) connect_sub -> COUNT[n-1]
     			| when (n == N) connect_pub -> COUNT[N]  // bloque si déjà au max
	 			).

// Test avec 2 et 3 pour pouvoir draw.
||CONTROLLER_SUB_SAME_ORIGIN_PUB = (i:COUNTER(1) || t:COUNTER(2)).
//************************************************************************//
// Question 11.3 (1 point)
// Définissez un processus SYSTEM11 qui met en parallèle SYSTEM10 et 
// CONTROLLER_SUB_SAME_ORIGIN_PUB.
//
// En utilisant le menu Check -> Run -> Default, assurez-vous que le problème
// identifié en 11.1 est corrigé.
//
// Vérifiez l'absence de blocage et de progrès.
// Réponse : Pas de blocage, ni violation de progrès.

||SYSTEM11 = (
    {APPS, PREFIXES_PUB}:PUB3 ||
    {APPS, PREFIXES_SUB}:SUB3 ||
    {APPS}:FORBIDDEN ||
    {APPS, PREFIXES}::BROKER4 ||
    {APPS}:FORBIDDEN_VALIDATOR ||
	CONTROLLER_SUB_SAME_ORIGIN_PUB
	) / {queue / {APPS, PREFIXES}.queue, dequeue / {APPS, PREFIXES}.dequeue}
  	\ {APPS.PREFIXES_PUB.SUB_LABELS, APPS.PREFIXES_SUB.PUB_LABELS}.

//************************************************************************//
//************************************************************************//



